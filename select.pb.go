// Code generated by protoc-gen-go.
// source: select.proto
// DO NOT EDIT!

package tipb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// KeyRange is the encoded index key ranges, low is closed, high is open. (low <= x < high)
type KeyRange struct {
	Low              []byte `protobuf:"bytes,1,opt,name=low" json:"low,omitempty"`
	High             []byte `protobuf:"bytes,2,opt,name=high" json:"high,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *KeyRange) Reset()                    { *m = KeyRange{} }
func (m *KeyRange) String() string            { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()               {}
func (*KeyRange) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *KeyRange) GetLow() []byte {
	if m != nil {
		return m.Low
	}
	return nil
}

func (m *KeyRange) GetHigh() []byte {
	if m != nil {
		return m.High
	}
	return nil
}

// ByItem type for group by and order by.
type ByItem struct {
	Expr             *Expr  `protobuf:"bytes,1,opt,name=expr" json:"expr,omitempty"`
	Desc             *bool  `protobuf:"varint,2,opt,name=desc" json:"desc,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ByItem) Reset()                    { *m = ByItem{} }
func (m *ByItem) String() string            { return proto.CompactTextString(m) }
func (*ByItem) ProtoMessage()               {}
func (*ByItem) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ByItem) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

func (m *ByItem) GetDesc() bool {
	if m != nil && m.Desc != nil {
		return *m.Desc
	}
	return false
}

// SelectRequest works like a simplified select statement.
type SelectRequest struct {
	// transaction start timestamp.
	StartTs *int64 `protobuf:"varint,1,opt,name=start_ts" json:"start_ts,omitempty"`
	// If table_info is not null, it represents a table scan, index_info would be null.
	TableInfo *TableInfo `protobuf:"bytes,2,opt,name=table_info" json:"table_info,omitempty"`
	// If IndexInfo is not null, it represents a index scan, table_info would be null.
	IndexInfo *IndexInfo `protobuf:"bytes,3,opt,name=index_info" json:"index_info,omitempty"`
	// fields to be selected, fields type can be column reference for simple scan.
	// or aggregation function. If no fields specified, only handle will be returned.
	Fields []*Expr `protobuf:"bytes,4,rep,name=fields" json:"fields,omitempty"`
	// disjoint handle ranges to be scanned.
	Ranges []*KeyRange `protobuf:"bytes,5,rep,name=ranges" json:"ranges,omitempty"`
	// handle points to be looked up.
	Points [][]byte `protobuf:"bytes,6,rep,name=points" json:"points,omitempty"`
	// distinct result.
	Distinct *bool `protobuf:"varint,7,opt,name=distinct" json:"distinct,omitempty"`
	// where condition.
	Where *Expr `protobuf:"bytes,8,opt,name=where" json:"where,omitempty"`
	// group by clause.
	GroupBy []*ByItem `protobuf:"bytes,9,rep,name=group_by" json:"group_by,omitempty"`
	// having clause.
	Having *Expr `protobuf:"bytes,10,opt,name=having" json:"having,omitempty"`
	// order by clause.
	OrderBy []*ByItem `protobuf:"bytes,11,rep,name=order_by" json:"order_by,omitempty"`
	// limit the result to be returned;
	Limit            *int64 `protobuf:"varint,12,opt,name=limit" json:"limit,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SelectRequest) Reset()                    { *m = SelectRequest{} }
func (m *SelectRequest) String() string            { return proto.CompactTextString(m) }
func (*SelectRequest) ProtoMessage()               {}
func (*SelectRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *SelectRequest) GetStartTs() int64 {
	if m != nil && m.StartTs != nil {
		return *m.StartTs
	}
	return 0
}

func (m *SelectRequest) GetTableInfo() *TableInfo {
	if m != nil {
		return m.TableInfo
	}
	return nil
}

func (m *SelectRequest) GetIndexInfo() *IndexInfo {
	if m != nil {
		return m.IndexInfo
	}
	return nil
}

func (m *SelectRequest) GetFields() []*Expr {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *SelectRequest) GetRanges() []*KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *SelectRequest) GetPoints() [][]byte {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *SelectRequest) GetDistinct() bool {
	if m != nil && m.Distinct != nil {
		return *m.Distinct
	}
	return false
}

func (m *SelectRequest) GetWhere() *Expr {
	if m != nil {
		return m.Where
	}
	return nil
}

func (m *SelectRequest) GetGroupBy() []*ByItem {
	if m != nil {
		return m.GroupBy
	}
	return nil
}

func (m *SelectRequest) GetHaving() *Expr {
	if m != nil {
		return m.Having
	}
	return nil
}

func (m *SelectRequest) GetOrderBy() []*ByItem {
	if m != nil {
		return m.OrderBy
	}
	return nil
}

func (m *SelectRequest) GetLimit() int64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

// values are all in text format.
type Row struct {
	Handle           []byte `protobuf:"bytes,1,opt,name=handle" json:"handle,omitempty"`
	Data             []byte `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Row) Reset()                    { *m = Row{} }
func (m *Row) String() string            { return proto.CompactTextString(m) }
func (*Row) ProtoMessage()               {}
func (*Row) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *Row) GetHandle() []byte {
	if m != nil {
		return m.Handle
	}
	return nil
}

func (m *Row) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Error struct {
	Code             *int32  `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Msg              *string `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *Error) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *Error) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

// Response for SelectRequest.
type SelectResponse struct {
	Error *Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	// Result rows.
	Rows []*Row `protobuf:"bytes,3,rep,name=rows" json:"rows,omitempty"`
	// If the requested key range has not finished scanning.
	// next_handle can be used to compose the range for the following request.
	// null means there is no more data to scan.
	NextHandle       []byte `protobuf:"bytes,4,opt,name=next_handle" json:"next_handle,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SelectResponse) Reset()                    { *m = SelectResponse{} }
func (m *SelectResponse) String() string            { return proto.CompactTextString(m) }
func (*SelectResponse) ProtoMessage()               {}
func (*SelectResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *SelectResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *SelectResponse) GetRows() []*Row {
	if m != nil {
		return m.Rows
	}
	return nil
}

func (m *SelectResponse) GetNextHandle() []byte {
	if m != nil {
		return m.NextHandle
	}
	return nil
}

func init() {
	proto.RegisterType((*KeyRange)(nil), "tipb.KeyRange")
	proto.RegisterType((*ByItem)(nil), "tipb.ByItem")
	proto.RegisterType((*SelectRequest)(nil), "tipb.SelectRequest")
	proto.RegisterType((*Row)(nil), "tipb.Row")
	proto.RegisterType((*Error)(nil), "tipb.Error")
	proto.RegisterType((*SelectResponse)(nil), "tipb.SelectResponse")
}

var fileDescriptor2 = []byte{
	// 427 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x92, 0xcf, 0x8e, 0xd3, 0x30,
	0x10, 0xc6, 0xd5, 0x6d, 0x12, 0xd2, 0x49, 0xb6, 0xac, 0x82, 0x10, 0xa6, 0x87, 0xd5, 0x2a, 0x2b,
	0x10, 0xa7, 0x0a, 0xed, 0x23, 0x54, 0xda, 0x43, 0xc5, 0x65, 0x55, 0x38, 0x71, 0xa9, 0xdc, 0x78,
	0x36, 0xb1, 0x94, 0xd8, 0xc1, 0xf6, 0xd2, 0xf6, 0x29, 0x79, 0x25, 0x3c, 0x76, 0xf8, 0x23, 0xd8,
	0x63, 0x66, 0xbe, 0x6f, 0xfc, 0x9b, 0xf9, 0x02, 0xa5, 0xc5, 0x1e, 0x1b, 0xb7, 0x1e, 0x8d, 0x76,
	0xba, 0x4a, 0x9c, 0x1c, 0x0f, 0xab, 0x2b, 0x3c, 0x8d, 0x06, 0xad, 0x95, 0x5a, 0xc5, 0xfa, 0xaa,
	0xb4, 0x4d, 0x87, 0x03, 0x8f, 0x5f, 0xf5, 0x3b, 0xc8, 0x3f, 0xe1, 0x79, 0xc7, 0x55, 0x8b, 0x55,
	0x01, 0xf3, 0x5e, 0x1f, 0xd9, 0xec, 0x66, 0xf6, 0xa1, 0xac, 0x4a, 0x48, 0x3a, 0xd9, 0x76, 0xec,
	0x82, 0xbe, 0xea, 0x8f, 0x90, 0x6d, 0xce, 0x5b, 0x87, 0x43, 0xc5, 0x20, 0xa1, 0x91, 0x41, 0x55,
	0xdc, 0xc1, 0x9a, 0x5e, 0x59, 0xdf, 0xfb, 0x0a, 0x39, 0x04, 0xda, 0x26, 0x38, 0xf2, 0xfa, 0xc7,
	0x05, 0x5c, 0x7e, 0x0e, 0x3c, 0x3b, 0xfc, 0xf6, 0x84, 0xd6, 0x55, 0x57, 0x90, 0x5b, 0xc7, 0x8d,
	0xdb, 0x3b, 0x1b, 0xdc, 0xf3, 0xea, 0x16, 0xc0, 0xf1, 0x43, 0x8f, 0x7b, 0xa9, 0x1e, 0x75, 0xf0,
	0x15, 0x77, 0x2f, 0xe3, 0xc4, 0x2f, 0x54, 0xdf, 0xfa, 0x32, 0x89, 0xa4, 0x12, 0x78, 0x8a, 0xa2,
	0xf9, 0xdf, 0xa2, 0x2d, 0xd5, 0x83, 0x68, 0x05, 0xd9, 0xa3, 0xc4, 0x5e, 0x58, 0x96, 0xdc, 0xcc,
	0xff, 0xe1, 0xba, 0x86, 0xcc, 0xd0, 0x7e, 0x96, 0xa5, 0xa1, 0xb7, 0x8c, 0xbd, 0xdf, 0x6b, 0x2f,
	0x21, 0x1b, 0xb5, 0x54, 0x9e, 0x2a, 0xf3, 0xfd, 0x92, 0x38, 0x85, 0xb4, 0x4e, 0xaa, 0xc6, 0xb1,
	0x17, 0xb4, 0x4b, 0xf5, 0x16, 0xd2, 0x63, 0x87, 0x06, 0x59, 0xfe, 0xdf, 0xd2, 0xd7, 0x90, 0xb7,
	0x46, 0x3f, 0x8d, 0xfb, 0xc3, 0x99, 0x2d, 0xc2, 0xf8, 0x32, 0x76, 0xa7, 0x73, 0x79, 0xb0, 0x8e,
	0x7f, 0x97, 0xaa, 0x65, 0xf0, 0x9c, 0x57, 0x1b, 0x81, 0x86, 0xbc, 0xc5, 0x33, 0xde, 0x4b, 0x48,
	0x7b, 0x39, 0x48, 0xc7, 0x4a, 0xba, 0x56, 0x7d, 0x0b, 0xf3, 0x9d, 0x3e, 0x12, 0x6e, 0xc7, 0x95,
	0xe8, 0xf1, 0x4f, 0x50, 0x82, 0x3b, 0x3e, 0x05, 0x55, 0x43, 0x7a, 0x6f, 0x8c, 0x0e, 0x69, 0x34,
	0x5a, 0x44, 0x51, 0x4a, 0xd1, 0x0e, 0xb6, 0x0d, 0x9a, 0x45, 0xfd, 0x15, 0x96, 0xbf, 0x92, 0xb1,
	0xa3, 0x56, 0x16, 0x3d, 0x65, 0x8a, 0xe4, 0x9a, 0x52, 0x2d, 0x26, 0xc8, 0x30, 0xe8, 0x0d, 0x24,
	0x46, 0x1f, 0xad, 0xbf, 0x3c, 0x11, 0x2e, 0x62, 0x8b, 0x40, 0x5e, 0x41, 0xa1, 0xf0, 0xe4, 0xf6,
	0x13, 0x4d, 0x42, 0xef, 0x6f, 0xde, 0xc3, 0xeb, 0x46, 0x0f, 0xeb, 0xd1, 0x6f, 0xdc, 0xf0, 0xd1,
	0x8b, 0xc5, 0x21, 0x38, 0x36, 0x45, 0x7c, 0xf2, 0x81, 0xfe, 0xba, 0x87, 0xd9, 0xcf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x47, 0xde, 0x9b, 0x00, 0xac, 0x02, 0x00, 0x00,
}
